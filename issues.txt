/*
Semafori
Gestione terminazioni
Definizione metodi nella libreria?

ATTIVATORE 
- controllo numero atomico < numero minimo -> scorie + 1 (memoria dinamica con contatore e code di messaggi)
- segnale scissione

SHARED MEMORY
Il funzionamento è simile a quello delle code di messaggi

! IMPORTANTE 
    Le interazioni con la shmem vanno regolate coi semafori: se qualcuno legge e non c'è nulla dà errore 
    Creo quindi un semaforo con semget

Per le operazioni di lettura e scrittura in shmem si usa memcpy (alternativamente si può creare anche una variabile con il
    puntatore come valore, ma ad esempio a Gabri non funzionava)


*/

// 

/*
COSE FATTE
Ripulire tutto a fine simulazione


Creazione shmem (shmget), collegamento a pointer (shmat), detach pointer (shmdt), deallocare shmem(shmctl)

ALIMENTATORE 
struct time gestisce tempo in nanosecondi; ogni tot nanosecondi crea nuovi atomi

ATOMO 
- fork dei figli
- condizione numero atomico minimo
- energia liberata: metodo (int n1, int n2) con figlio1 che passa n1 e figlio2 che passa n2


Makefile
*/



/*
MAKEFILE VERSIONE VECCHIA FUNZIONANTE

init: master atomo attivatore alimentatore library.h

master: master.c library.h
	gcc master.c -Wvla -Wextra -Werror -o master

atomo: atomo.c library.h
	gcc atomo.c -Wvla -Wextra -Werror -o atomo

attivatore: attivatore.c library.h
	gcc attivatore.c -Wvla -Wextra -Werror -o attivatore

alimentatore: alimentatore.c library.h
	gcc alimentatore.c -Wvla -Wextra -Werror -o alimentatore

inibitore: inibitore.c library.h
	gcc inibitore.c -Wvla -Wextra -Werror -o inibitore
	
run: 
	./master

clean:
	rm -f *.o















VERSIONE NUOVA NO FUNZIONANTE
CC = gcc
CFLAGS = -Wvla -Wextra -Werror
INCLUDES = library.h
DEPENDENCIES = $(INCLUDES) folders

init: code/methods code/master code/atomo code/attivatore code/alimentatore code/inibitore $(INCLUDES)

run: code/master

folders:
	mkdir -p object/ code/

#code/%.c: ./%.c $(DEPENDENCIES)
#$(CC) $(CFLAGS) -c $< -o $@

object/%.o: /%.c $(DEPENDENCIES)
	$(CC) $(CFLAGS) -c $< -o $@


code/master: object/master.o $(DEPENDENCIES)
	$(CC) -o code/master

code/atomo: object/atomo.o $(DEPENDENCIES)
	$(CC) -o code/atomo

code/attivatore: object/attivatore.o $(DEPENDENCIES)
	$(CC) -o code/attivatore
	
code/alimentatore: object/alimentatore.o $(DEPENDENCIES)
	$(CC) -o code/alimentatore

code/inibitore: object/inibitore.o $(DEPENDENCIES)
	$(CC) -o code/inibitore

code/methods: object/methods.o $(DEPENDENCIES)
	$(CC) -o code/methods

clean:
	rm -rf object/ code/









LIBRARY.H

	/**
 * Struct to handle semaphore ops
*/
struct sembuf sem;


/**
 * Shared memory: stats and termination reason
*/
typedef struct data_buffer data_buffer;

/**
 * Prints stats from shared memory
*/
void print_stats(data_buffer *);

/**
 * Calculates the value for total stats from relative values
*/
void stat_total_value();

/**
 * Calculates energy produced during divisions
*/
int energy(int, int);




//! LI TENIAMO?

/* int createSem(key_t key, int semnum) {
  return semget(key, semnum, IPC_CREAT | 0666);
}

int initSem(int semid, int semnum, int arg) {
  return semctl(semid, semnum, SETVAL, arg);
}

int reserveSem(int semid, int semnum, int val) {
  struct sembuf sem;
  sem.sem_num = semnum;
  sem.sem_op = -1;
  sem.sem_flg = 0;
  return semop(semid, &sem, val);
}

int releaseSem(int semid, int semnum) {
  struct sembuf sem;
  sem.sem_num = semnum;
  sem.sem_op = 1;
  sem.sem_flg = 0;
  return semop(semid, &sem, 1);
} */
*/